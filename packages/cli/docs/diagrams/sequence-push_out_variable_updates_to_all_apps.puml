@startuml
'https://plantuml.com/sequence-diagram

autonumber

title sequence diagram - push variable updates out to a new materialized config for each service
actor ServiceDeveloper

ServiceDeveloper -> GH_repo: A developer publishes a new release on the monorepo
GH_repo -> cenv_ci_cd: The cenv_ci_cd github action workflow invokes determines that a new release has been published
cenv_ci_cd -> cenv_cli: The cenv_ci_cd github action calls 'cenv deploy -aa' which intern executes 'cenv deploy' on each service that uses cenv
cenv_cli -> AWS_ParameterStore: The cenv_cli then updates and or writes and updated parameters to the AWS Parameter Store service
cenv_cli -> AWS_AppConfig: Then the cli will create an AppConfig deployment against the 'cenv' application
AWS_AppConfig -> SNS_materialization_topic: Then the cenv AppConfig app will send a notification via the cenv_materialization_topic
SNS_materialization_topic -> CENV_materialization_lambda: The SNS_materialization_topic will deliver the deployment notification to the cenv_materialization_lambda
CENV_materialization_lambda -> AWS_AppConfig: The cenv_materialization_lambda will then materialize all the parameters required for each service into a config file and write it to the apps's AppConfig configuration profile
AWS_AppConfig -> SNS_invalidation_topic: Then the cenv AppConfig will send a notification to the SNS_invalidateion_topic
SNS_invalidateion_topic -> CENV_invalidation_lambda: The SNS_invalidation_topic will deliver the notification to the cenv_invalidation_lambda
cenv_invalidation_lambda -> AWS_Lambda: The cenv_invalidation_lambda will then invalidate any lambdas tied to this service config by updating an environment variable on the lambda with a new timestamp (which invalidates functions and forces them back into a spot where it needs to perform a cold start before it can execute again)
@enduml
